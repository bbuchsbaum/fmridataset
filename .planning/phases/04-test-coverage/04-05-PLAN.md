---
phase: 04-test-coverage
plan: 05
type: execute
wave: 1
depends_on: ["01", "02", "03", "04"]
files_modified:
  - tests/testthat/test-as_delarr.R
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "as_delarr.R coverage is 80%+ (target from as_delayed_array gap)"
    - "All 4 S3 methods are tested (matrix_backend, nifti_backend, study_backend, default)"
    - "Error paths in study_backend pull function are tested (bounds, types, empty)"
  artifacts:
    - path: "tests/testthat/test-as_delarr.R"
      provides: "Comprehensive delarr conversion tests"
      min_lines: 150
      contains:
        - "as_delarr.matrix_backend"
        - "as_delarr.nifti_backend"
        - "as_delarr.study_backend"
        - "as_delarr.default"
  key_links:
    - from: "tests/testthat/test-as_delarr.R"
      to: "R/as_delarr.R"
      via: "Tests as_delarr() generic and all S3 methods"
      pattern: "as_delarr\\("
    - from: "tests/testthat/test-as_delarr.R"
      to: "tests/testthat/helper-backends.R"
      via: "Uses create_test_matrix for test data"
      pattern: "create_test_matrix"
---

<objective>
Add comprehensive test coverage for as_delarr.R (currently 67.3%, target 80%+).

Purpose: as_delarr.R is the PRIMARY lazy array interface (delarr is in Imports, not optional like DelayedArray). This gap closure plan ensures the core lazy array functionality is well-tested before Phase 5 CRAN validation.

Output: tests/testthat/test-as_delarr.R with tests for all S3 methods and error paths
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-test-coverage/04-VERIFICATION.md
@R/as_delarr.R
@tests/testthat/helper-backends.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test-as_delarr.R with matrix_backend and nifti_backend tests</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Create `tests/testthat/test-as_delarr.R` with comprehensive tests for the delarr conversion interface.

**Section 1: matrix_backend conversion (as_delarr.matrix_backend)**

```r
# Test as_delarr.matrix_backend
test_that("as_delarr.matrix_backend returns delarr object", {
  mat <- create_test_matrix(n_time = 20, n_voxels = 50)
  backend <- matrix_backend(mat)

  result <- as_delarr(backend)

  expect_s3_class(result, "delarr")
  expect_equal(nrow(result), 20)
  expect_equal(ncol(result), 50)
})

test_that("as_delarr.matrix_backend pull function retrieves correct data", {
  mat <- create_test_matrix(n_time = 15, n_voxels = 30)
  backend <- matrix_backend(mat)

  darr <- as_delarr(backend)

  # Full materialization
  realized <- delarr::collect(darr)
  expect_equal(realized, mat, tolerance = 1e-10)

  # Subset retrieval via delarr pull
  subset <- darr[1:5, 1:10]
  subset_realized <- delarr::collect(subset)
  expect_equal(subset_realized, mat[1:5, 1:10], tolerance = 1e-10)
})

test_that("as_delarr.matrix_backend handles single row", {
  mat <- matrix(rnorm(20), nrow = 1, ncol = 20)
  backend <- matrix_backend(mat)

  result <- as_delarr(backend)
  expect_equal(nrow(result), 1)
  expect_equal(ncol(result), 20)

  realized <- delarr::collect(result)
  expect_equal(realized, mat, tolerance = 1e-10)
})

test_that("as_delarr.matrix_backend handles single column", {
  mat <- matrix(rnorm(15), nrow = 15, ncol = 1)
  backend <- matrix_backend(mat)

  result <- as_delarr(backend)
  expect_equal(nrow(result), 15)
  expect_equal(ncol(result), 1)
})
```

**Section 2: nifti_backend conversion (as_delarr.nifti_backend)**

Create minimal nifti_backend mocks (similar to h5_backend pattern). Since nifti_backend requires neuroim2 NeuroVec objects, use `skip_if_not_installed("neuroim2")` and create a helper for minimal nifti backend:

```r
# Test as_delarr.nifti_backend
test_that("as_delarr.nifti_backend returns delarr object", {
  skip_if_not_installed("neuroim2")

  # Create minimal backend with mock structure
  mat <- create_test_matrix(n_time = 10, n_voxels = 64)
  mock_backend <- structure(
    list(
      data_matrix = mat,
      `_dims` = list(spatial = c(4, 4, 4), time = 10),
      `_mask` = rep(TRUE, 64),
      `_opened` = TRUE
    ),
    class = c("nifti_backend", "storage_backend")
  )

  # Register mock methods for backend_get_dims, backend_get_mask, backend_get_data
  # (Use withr::local_options or local method registration)

  # Test conversion
  result <- as_delarr(mock_backend)
  expect_s3_class(result, "delarr")
})
```

Note: If nifti_backend mocking is complex, use a skip condition and document. The primary goal is matrix_backend and study_backend coverage.

**File structure:**
```r
# Tests for as_delarr.R - delarr lazy matrix interface
# as_delarr is the PRIMARY lazy array path (delarr is in Imports)

# Section 1: matrix_backend conversion ----
# (tests above)

# Section 2: nifti_backend conversion ----
# (tests above)
```
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
if (!file.exists('tests/testthat/test-as_delarr.R')) stop('test-as_delarr.R not created')
content <- readLines('tests/testthat/test-as_delarr.R')
if (length(content) < 50) stop('File too short: ', length(content), ' lines')
if (!any(grepl('matrix_backend', content))) stop('Missing matrix_backend tests')
cat('Task 1 verification: PASSED\n')
cat('- File exists: YES\n')
cat('- Lines:', length(content), '\n')
cat('- Contains matrix_backend tests: YES\n')
"
```
  </verify>
  <done>test-as_delarr.R created with matrix_backend and nifti_backend sections</done>
</task>

<task type="auto">
  <name>Task 2: Add study_backend tests with error path coverage</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Add Section 3 to test-as_delarr.R for study_backend conversion. This is the most complex method with significant error handling logic (lines 75-117 of as_delarr.R).

**Section 3: study_backend conversion (as_delarr.study_backend)**

```r
# Section 3: study_backend conversion ----

test_that("as_delarr.study_backend returns delarr object", {
  # Create two matrix backends to combine
  mat1 <- create_test_matrix(n_time = 10, n_voxels = 50)
  mat2 <- create_test_matrix(n_time = 15, n_voxels = 50)
  set.seed(43)  # Different seed for second matrix
  mat2 <- matrix(rnorm(15 * 50), nrow = 15, ncol = 50)

  backend1 <- matrix_backend(mat1)
  backend2 <- matrix_backend(mat2)

  study <- study_backend(list(backend1, backend2))

  result <- as_delarr(study)

  expect_s3_class(result, "delarr")
  expect_equal(nrow(result), 25)  # 10 + 15
  expect_equal(ncol(result), 50)
})

test_that("as_delarr.study_backend pull function returns correct data", {
  mat1 <- create_test_matrix(n_time = 8, n_voxels = 30)
  set.seed(99)
  mat2 <- matrix(rnorm(12 * 30), nrow = 12, ncol = 30)

  backend1 <- matrix_backend(mat1)
  backend2 <- matrix_backend(mat2)

  study <- study_backend(list(backend1, backend2))
  darr <- as_delarr(study)

  # Full materialization
  realized <- delarr::collect(darr)
  expected <- rbind(mat1, mat2)
  expect_equal(realized, expected, tolerance = 1e-10)
})

test_that("as_delarr.study_backend handles logical row indices", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 20)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Logical subsetting (lines 79-80 of as_delarr.R)
  rows_logical <- c(TRUE, FALSE, TRUE, FALSE, TRUE)
  subset <- darr[rows_logical, ]
  realized <- delarr::collect(subset)
  expect_equal(nrow(realized), 3)
})

test_that("as_delarr.study_backend handles logical column indices", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  cols_logical <- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
  subset <- darr[, cols_logical]
  realized <- delarr::collect(subset)
  expect_equal(ncol(realized), 3)
})

test_that("as_delarr.study_backend errors on out-of-bounds rows", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Row indices out of bounds (line 82-84 of as_delarr.R)
  expect_error(
    delarr::collect(darr[1:10, ]),  # Only 5 rows exist
    "Row indices out of bounds"
  )

  expect_error(
    delarr::collect(darr[0:3, ]),  # Row 0 invalid
    "Row indices out of bounds"
  )
})

test_that("as_delarr.study_backend errors on out-of-bounds cols", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Column indices out of bounds (line 85-87 of as_delarr.R)
  expect_error(
    delarr::collect(darr[, 1:20]),  # Only 10 cols exist
    "Column indices out of bounds"
  )
})

test_that("as_delarr.study_backend returns empty matrix for empty indices", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Empty rows (line 89-91 of as_delarr.R)
  subset <- darr[integer(0), ]
  realized <- delarr::collect(subset)
  expect_equal(nrow(realized), 0)
  expect_equal(ncol(realized), 10)

  # Empty cols
  subset2 <- darr[, integer(0)]
  realized2 <- delarr::collect(subset2)
  expect_equal(nrow(realized2), 5)
  expect_equal(ncol(realized2), 0)
})

test_that("as_delarr.study_backend converts double indices to integer", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Double indices that are integer-valued (lines 93-107 of as_delarr.R)
  subset <- darr[c(1.0, 2.0, 3.0), c(1.0, 2.0)]
  realized <- delarr::collect(subset)
  expect_equal(dim(realized), c(3, 2))
})

test_that("as_delarr.study_backend errors on non-integer double indices", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat1)
  study <- study_backend(list(backend))

  darr <- as_delarr(study)

  # Non-integer doubles should error (lines 96-98, 104-106 of as_delarr.R)
  expect_error(
    delarr::collect(darr[c(1.5, 2.5), ]),
    "Row indices must be integer valued"
  )

  expect_error(
    delarr::collect(darr[, c(1.5, 2.5)]),
    "Column indices must be integer valued"
  )
})

test_that("as_delarr.study_backend retrieves data across subject boundaries", {
  mat1 <- create_test_matrix(n_time = 5, n_voxels = 20)
  set.seed(77)
  mat2 <- matrix(rnorm(7 * 20), nrow = 7, ncol = 20)

  backend1 <- matrix_backend(mat1)
  backend2 <- matrix_backend(mat2)

  study <- study_backend(list(backend1, backend2))
  darr <- as_delarr(study)

  # Retrieve rows spanning both subjects (rows 4-8 cross boundary at row 5)
  subset <- darr[4:8, 1:5]
  realized <- delarr::collect(subset)

  expect_equal(dim(realized), c(5, 5))
  # First 2 rows from mat1, last 3 from mat2
  expect_equal(realized[1:2, ], mat1[4:5, 1:5], tolerance = 1e-10)
  expect_equal(realized[3:5, ], mat2[1:3, 1:5], tolerance = 1e-10)
})
```

**Key coverage targets:**
- Lines 75-77: NULL rows/cols default handling
- Lines 79-80: Logical to integer conversion
- Lines 82-87: Bounds checking errors
- Lines 89-91: Empty result handling
- Lines 93-107: Double to integer conversion and errors
- Lines 109-116: Cross-subject boundary retrieval
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
content <- readLines('tests/testthat/test-as_delarr.R')
tests <- grep('test_that\\(', content, value = TRUE)
study_tests <- grep('study_backend', tests)
if (length(study_tests) < 5) stop('Need at least 5 study_backend tests, found: ', length(study_tests))

# Check for error path coverage
if (!any(grepl('out.of.bounds', content, ignore.case = TRUE))) stop('Missing bounds error tests')
if (!any(grepl('integer.valued', content, ignore.case = TRUE))) stop('Missing type error tests')

cat('Task 2 verification: PASSED\n')
cat('- study_backend tests:', length(study_tests), '\n')
cat('- Has bounds error tests: YES\n')
cat('- Has type error tests: YES\n')
"
```
  </verify>
  <done>study_backend tests added with error path coverage (bounds, types, empty results)</done>
</task>

<task type="auto">
  <name>Task 3: Add default method test and verify coverage improvement</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Add Section 4 to test the default method (error for unknown types) and run coverage verification.

**Section 4: Default method and edge cases**

```r
# Section 4: Default method and edge cases ----

test_that("as_delarr.default errors for unknown backend types", {
  # Line 128-130 of as_delarr.R
  unknown_obj <- structure(list(data = 1:10), class = "unknown_backend")

  expect_error(
    as_delarr(unknown_obj),
    "No as_delarr method for class: unknown_backend"
  )
})

test_that("as_delarr.default shows first class in error message", {
  multi_class <- structure(list(), class = c("first_class", "second_class"))

  expect_error(
    as_delarr(multi_class),
    "No as_delarr method for class: first_class"
  )
})

test_that("as_delarr generic dispatches correctly", {
  # Verify S3 dispatch works
  mat <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat)

  # Should dispatch to as_delarr.matrix_backend
  result <- as_delarr(backend)
  expect_s3_class(result, "delarr")
})
```

**Run coverage verification:**

After tests pass, verify coverage improvement:

```r
# Coverage check (run after tests complete)
cov <- covr::file_coverage("R/as_delarr.R", "tests/testthat/test-as_delarr.R")
pct <- covr::percent_coverage(cov)
cat("as_delarr.R coverage:", round(pct, 1), "%\n")
# Target: 80%+
```
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
# Verify test file is complete
content <- readLines('tests/testthat/test-as_delarr.R')
cat('Total lines:', length(content), '\n')

# Count test_that blocks
tests <- grep('test_that\\(', content)
cat('Total test_that blocks:', length(tests), '\n')

# Verify all sections present
if (!any(grepl('Section 1', content))) stop('Missing Section 1')
if (!any(grepl('Section 3', content))) stop('Missing Section 3')
if (!any(grepl('Section 4', content))) stop('Missing Section 4')
if (!any(grepl('as_delarr.default', content))) stop('Missing default method tests')

cat('Task 3 verification: PASSED\n')
cat('- All 4 sections present: YES\n')
cat('- Default method tested: YES\n')

# Run tests
cat('\nRunning tests...\n')
testthat::test_file('tests/testthat/test-as_delarr.R')
"
```
  </verify>
  <done>Default method tests added, all tests pass, file structure complete</done>
</task>

</tasks>

<verification>
1. test-as_delarr.R exists with >= 150 lines
2. All 4 S3 methods tested (matrix_backend, nifti_backend, study_backend, default)
3. Error paths in study_backend tested (bounds checking, type checking, empty results)
4. All tests pass: `devtools::test(filter = "as_delarr")`
5. Coverage improved: `covr::file_coverage("R/as_delarr.R", "tests/testthat/test-as_delarr.R")` >= 80%

```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
# Final verification
cat('=== Final Verification ===\n\n')

# 1. File exists and has content
content <- readLines('tests/testthat/test-as_delarr.R')
cat('1. File lines:', length(content), '(target: >= 150)\n')

# 2. Test coverage
result <- devtools::test(filter = 'as_delarr', reporter = 'summary')
if (any(as.data.frame(result)\$failed > 0)) {
  cat('2. Tests: FAILED\n')
} else {
  cat('2. Tests: PASSED\n')
}

# 3. Coverage check
cov <- covr::file_coverage('R/as_delarr.R', 'tests/testthat/test-as_delarr.R')
pct <- covr::percent_coverage(cov)
cat('3. Coverage:', round(pct, 1), '% (target: >= 80%)\n')
cat('   Status:', ifelse(pct >= 80, 'TARGET MET', 'BELOW TARGET'), '\n')
"
```
</verification>

<success_criteria>
- test-as_delarr.R exists with 150+ lines covering all S3 methods
- All tests pass with zero failures
- as_delarr.R coverage >= 80% (improved from 67.3%)
- Error paths tested: out-of-bounds rows/cols, non-integer indices, empty results
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-05-SUMMARY.md`
</output>
