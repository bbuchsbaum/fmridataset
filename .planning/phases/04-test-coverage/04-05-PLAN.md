---
phase: 04-test-coverage
plan: 05
type: execute
wave: 1
depends_on: ["01"]
files_modified:
  - tests/testthat/test-as_delarr.R
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "matrix_backend converts to delarr lazy matrix without full materialization"
    - "study_backend with multiple subjects returns correct data across subject boundaries"
    - "Invalid row/column indices produce clear error messages ('out of bounds', 'must be integer valued')"
    - "3 of 4 S3 methods tested (nifti_backend skipped due to neuroim2 S4 dependency)"
  artifacts:
    - path: "tests/testthat/test-as_delarr.R"
      provides: "Comprehensive delarr conversion tests"
      min_lines: 200
      contains:
        - "as_delarr.matrix_backend"
        - "as_delarr.study_backend"
        - "as_delarr.default"
  key_links:
    - from: "tests/testthat/test-as_delarr.R"
      to: "R/as_delarr.R"
      via: "Tests as_delarr() generic and S3 methods"
      pattern: "as_delarr\\("
    - from: "tests/testthat/test-as_delarr.R"
      to: "tests/testthat/helper-backends.R"
      via: "Uses create_test_matrix for test data"
      pattern: "create_test_matrix"
---

<objective>
Add comprehensive test coverage for as_delarr.R (currently 67.3%, target 80%+).

Purpose: as_delarr.R is the PRIMARY lazy array interface (delarr is in Imports, not optional like DelayedArray). This gap closure plan ensures the core lazy array functionality is well-tested before Phase 5 CRAN validation.

Output: tests/testthat/test-as_delarr.R with tests for all S3 methods and error paths
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-test-coverage/04-VERIFICATION.md
@R/as_delarr.R
@tests/testthat/helper-backends.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test-as_delarr.R with matrix_backend tests</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Create `tests/testthat/test-as_delarr.R` with comprehensive tests for the delarr conversion interface.

**Section 1: matrix_backend conversion (as_delarr.matrix_backend)**

Test categories:
- Basic conversion (returns delarr object with correct dimensions)
- Data retrieval via pull function (full materialization, subset retrieval)
- Edge cases (single row, single column)

```r
# Tests for as_delarr.R - delarr lazy matrix interface
# as_delarr is the PRIMARY lazy array path (delarr is in Imports)

# Section 1: matrix_backend conversion ----
test_that("as_delarr.matrix_backend returns delarr object", {
  mat <- create_test_matrix(n_time = 20, n_voxels = 50)
  backend <- matrix_backend(mat)
  result <- as_delarr(backend)

  expect_s3_class(result, "delarr")
  expect_equal(nrow(result), 20)
  expect_equal(ncol(result), 50)
})

test_that("as_delarr.matrix_backend pull function retrieves correct data", {
  mat <- create_test_matrix(n_time = 15, n_voxels = 30)
  backend <- matrix_backend(mat)
  darr <- as_delarr(backend)

  # Full materialization
  realized <- delarr::collect(darr)
  expect_equal(realized, mat, tolerance = 1e-10)

  # Subset retrieval
  subset <- darr[1:5, 1:10]
  subset_realized <- delarr::collect(subset)
  expect_equal(subset_realized, mat[1:5, 1:10], tolerance = 1e-10)
})

test_that("as_delarr.matrix_backend handles single row", {
  mat <- matrix(rnorm(20), nrow = 1, ncol = 20)
  backend <- matrix_backend(mat)
  result <- as_delarr(backend)

  expect_equal(nrow(result), 1)
  expect_equal(ncol(result), 20)
  realized <- delarr::collect(result)
  expect_equal(realized, mat, tolerance = 1e-10)
})

test_that("as_delarr.matrix_backend handles single column", {
  mat <- matrix(rnorm(15), nrow = 15, ncol = 1)
  backend <- matrix_backend(mat)
  result <- as_delarr(backend)

  expect_equal(nrow(result), 15)
  expect_equal(ncol(result), 1)
})
```

**SKIP nifti_backend:**
nifti_backend requires neuroim2 S4 NeuroVec objects, making comprehensive testing impractical without complex mocking (same limitation as h5_backend in plan 04). Focus on matrix_backend and study_backend which provide sufficient coverage of the core interface.

**File structure:**
```r
# Tests for as_delarr.R - delarr lazy matrix interface

# Section 1: matrix_backend conversion ----
# (tests above)

# NOTE: nifti_backend skipped - requires neuroim2 S4 objects (complex mocking)
```
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
if (!file.exists('tests/testthat/test-as_delarr.R')) stop('test-as_delarr.R not created')
content <- readLines('tests/testthat/test-as_delarr.R')
if (length(content) < 50) stop('File too short: ', length(content), ' lines')
if (!any(grepl('matrix_backend', content))) stop('Missing matrix_backend tests')
cat('Task 1 verification: PASSED\n')
cat('- File exists: YES\n')
cat('- Lines:', length(content), '\n')
cat('- Contains matrix_backend tests: YES\n')
"
```
  </verify>
  <done>test-as_delarr.R created with matrix_backend section</done>
</task>

<task type="auto">
  <name>Task 2: Add study_backend tests with error path coverage</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Add Section 2 to test-as_delarr.R for study_backend conversion. This is the most complex method with significant error handling logic (lines 75-117 of as_delarr.R).

**Section 2: study_backend conversion (as_delarr.study_backend)**

Test categories:
1. Basic multi-subject conversion (returns delarr with combined dimensions)
2. Data retrieval across boundaries (rows spanning multiple subjects)
3. Index type handling (logical indices, double-to-integer conversion)
4. Error paths:
   - Out-of-bounds rows/columns (lines 82-87)
   - Non-integer double indices (lines 96-98, 104-106)
   - Empty index handling (lines 89-91)

Create tests covering:
- `study_backend(list(backend1, backend2))` conversion to delarr
- Pull function retrieving data across subject boundaries
- Logical row/column subsetting (lines 79-80)
- Bounds error conditions (row/col out of range)
- Type error conditions (non-integer doubles)
- Empty result handling (integer(0) indices)
- Integer-valued double conversion (1.0, 2.0)

Example test structure:
```r
test_that("as_delarr.study_backend returns delarr object", {
  mat1 <- create_test_matrix(n_time = 10, n_voxels = 50)
  mat2 <- create_test_matrix(n_time = 15, n_voxels = 50)
  # ... create study_backend, test conversion
})

test_that("as_delarr.study_backend retrieves data across subject boundaries", {
  # Test rows 4-8 when boundary is at row 5
})

test_that("as_delarr.study_backend errors on out-of-bounds rows", {
  # Test line 82-84: expect_error(..., "Row indices out of bounds")
})
# ... (additional 7+ tests covering error paths)
```
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
content <- readLines('tests/testthat/test-as_delarr.R')
tests <- grep('test_that\\(', content, value = TRUE)
study_tests <- grep('study_backend', tests)
if (length(study_tests) < 5) stop('Need at least 5 study_backend tests, found: ', length(study_tests))

# Check for error path coverage
if (!any(grepl('out.of.bounds', content, ignore.case = TRUE))) stop('Missing bounds error tests')
if (!any(grepl('integer.valued', content, ignore.case = TRUE))) stop('Missing type error tests')

cat('Task 2 verification: PASSED\n')
cat('- study_backend tests:', length(study_tests), '\n')
cat('- Has bounds error tests: YES\n')
cat('- Has type error tests: YES\n')
"
```
  </verify>
  <done>study_backend tests added with error path coverage (bounds, types, empty results)</done>
</task>

<task type="auto">
  <name>Task 3: Add default method test and verify coverage improvement</name>
  <files>tests/testthat/test-as_delarr.R</files>
  <action>
Add Section 3 to test the default method (error for unknown types) and run coverage verification.

**Section 3: Default method and edge cases**

Test categories:
- Default method error for unknown backend types (lines 128-130)
- Error message shows first class name
- Generic dispatch works correctly

```r
# Section 3: Default method and edge cases ----

test_that("as_delarr.default errors for unknown backend types", {
  unknown_obj <- structure(list(data = 1:10), class = "unknown_backend")
  expect_error(
    as_delarr(unknown_obj),
    "No as_delarr method for class: unknown_backend"
  )
})

test_that("as_delarr.default shows first class in error message", {
  multi_class <- structure(list(), class = c("first_class", "second_class"))
  expect_error(
    as_delarr(multi_class),
    "No as_delarr method for class: first_class"
  )
})

test_that("as_delarr generic dispatches correctly", {
  mat <- create_test_matrix(n_time = 5, n_voxels = 10)
  backend <- matrix_backend(mat)
  result <- as_delarr(backend)
  expect_s3_class(result, "delarr")
})
```

Run coverage verification after tests complete:
```r
cov <- covr::file_coverage("R/as_delarr.R", "tests/testthat/test-as_delarr.R")
pct <- covr::percent_coverage(cov)
# Target: 80%+
```
  </action>
  <verify>
```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
# Verify test file is complete
content <- readLines('tests/testthat/test-as_delarr.R')
cat('Total lines:', length(content), '\n')

# Count test_that blocks
tests <- grep('test_that\\(', content)
cat('Total test_that blocks:', length(tests), '\n')

# Verify all sections present
if (!any(grepl('Section 1', content))) stop('Missing Section 1')
if (!any(grepl('Section 2', content))) stop('Missing Section 2')
if (!any(grepl('Section 3', content))) stop('Missing Section 3')
if (!any(grepl('as_delarr.default', content))) stop('Missing default method tests')

cat('Task 3 verification: PASSED\n')
cat('- All 3 sections present: YES\n')
cat('- Default method tested: YES\n')

# Run tests
cat('\nRunning tests...\n')
testthat::test_file('tests/testthat/test-as_delarr.R')
"
```
  </verify>
  <done>Default method tests added, all tests pass, file structure complete</done>
</task>

</tasks>

<verification>
1. test-as_delarr.R exists with >= 200 lines
2. 3 of 4 S3 methods tested (matrix_backend, study_backend, default; nifti_backend skipped)
3. Error paths in study_backend tested (bounds checking, type checking, empty results)
4. All tests pass: `testthat::test_file('tests/testthat/test-as_delarr.R')`
5. Coverage improved: `covr::file_coverage("R/as_delarr.R", "tests/testthat/test-as_delarr.R")` >= 80%

```bash
cd /Users/bbuchsbaum/code/fmridataset && Rscript -e "
# Final verification
cat('=== Final Verification ===\n\n')

# 1. File exists and has content
content <- readLines('tests/testthat/test-as_delarr.R')
cat('1. File lines:', length(content), '(target: >= 200)\n')

# 2. Test coverage
result <- devtools::test(filter = 'as_delarr', reporter = 'summary')
if (any(as.data.frame(result)\$failed > 0)) {
  cat('2. Tests: FAILED\n')
} else {
  cat('2. Tests: PASSED\n')
}

# 3. Coverage check
cov <- covr::file_coverage('R/as_delarr.R', 'tests/testthat/test-as_delarr.R')
pct <- covr::percent_coverage(cov)
cat('3. Coverage:', round(pct, 1), '% (target: >= 80%)\n')
cat('   Status:', ifelse(pct >= 80, 'TARGET MET', 'BELOW TARGET'), '\n')
"
```
</verification>

<success_criteria>
- test-as_delarr.R exists with 200+ lines covering 3 of 4 S3 methods
- All tests pass with zero failures
- as_delarr.R coverage >= 80% (improved from 67.3%)
- Error paths tested: out-of-bounds rows/cols, non-integer indices, empty results
- nifti_backend skipped with documented reason (S4 dependency complexity)
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-05-SUMMARY.md`
</output>
