% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backends.R
\name{latent_backend}
\alias{latent_backend}
\title{Create a Latent Backend}
\usage{
latent_backend(source, mask_source = NULL, preload = FALSE)
}
\arguments{
\item{source}{A character vector of file paths to LatentNeuroVec HDF5 files (.lv.h5),
or a list of LatentNeuroVec objects from the fmristore package.}

\item{mask_source}{Optional mask source. If NULL, the mask will be extracted from
the first LatentNeuroVec object.}

\item{preload}{Logical indicating whether to preload all data into memory.
Default is FALSE (lazy loading).}
}
\value{
A \code{latent_backend} object that implements the storage backend interface.
}
\description{
Creates a storage backend for accessing latent space representations of fMRI data
using LatentNeuroVec objects from the fmristore package. This backend provides
efficient access to data stored in a compressed latent space format.
}
\details{
The latent backend supports LatentNeuroVec objects which store fMRI data in a
compressed latent space representation using basis functions and spatial loadings.
This format is particularly efficient for data that can be well-represented by
a lower-dimensional basis (e.g., from PCA, ICA, or dictionary learning).

\strong{LatentNeuroVec Structure:}
\itemize{
\item \code{basis}: Temporal components (n_timepoints × k_components)
\item \code{loadings}: Spatial components (n_voxels × k_components)
\item \code{offset}: Optional per-voxel offset terms
\item Data is reconstructed as: \code{data = basis \%*\% t(loadings) + offset}
}

\strong{IMPORTANT: Data Access Behavior}
Unlike other backends that return voxel-wise data, the latent_backend returns
\strong{latent scores} (the basis/temporal components) rather than reconstructed voxel data.
This is because:
\itemize{
\item Analyses are typically performed in the latent space for efficiency
\item The latent scores capture the temporal dynamics in the compressed representation
\item Reconstructing to ambient voxel space defeats the purpose of the compression
\item \code{backend_get_data()} returns a matrix of size (time × components), not (time × voxels)
\item \code{backend_get_mask()} returns a logical vector indicating active components, not spatial voxels
}

\strong{Supported Input Types:}
\itemize{
\item File paths to \code{.lv.h5} files (LatentNeuroVec HDF5 format)
\item Pre-loaded LatentNeuroVec objects
\item Mixed lists of files and objects
}
}
\examples{
\dontrun{
# From LatentNeuroVec HDF5 files
backend <- latent_backend(
  source = c("run1.lv.h5", "run2.lv.h5", "run3.lv.h5")
)

# From pre-loaded LatentNeuroVec objects
lvec1 <- fmristore::read_vec("run1.lv.h5")
lvec2 <- fmristore::read_vec("run2.lv.h5")
backend <- latent_backend(source = list(lvec1, lvec2))

# Mixed sources
backend <- latent_backend(
  source = list(lvec1, "run2.lv.h5", "run3.lv.h5")
)
}

}
\seealso{
\code{\link{h5_backend}}, \code{\link{nifti_backend}}, \code{\link{matrix_backend}}
}
